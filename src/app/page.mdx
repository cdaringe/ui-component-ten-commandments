<h1 className="text-center text-3xl md:text-4xl font-bold">
  UI Component Ten Commandments
</h1>

<span className="text-justify">
  Behold! The etchings on this tablet
  contain essential wisdom for building
  excellent components. No singular
  commandment is greater than his
  brother, and no singular commandment
  is lesser than his sister. The
  following commandments do not always
  implement one another. Do not foresake
  them! Each commandment authored to be
  concise, thus focuses only on the
  principle at hand!
</span>

<span className="text-sm">
  The following commandments are not
  specifically tailored for [web
  components](https://developer.mozilla.org/en-US/docs/Web/API/Web_components).
</span>

<hr />

## 1. Thou shalt specify declarative interfaces

**Principle**: Declarative UI, Principle of least astonishment

```tsx
type Props = {
  // `isOpen` declares the modal to be open or closed.
  // clear semantics make the component intuitive and
  // predictable.
  isOpen: boolean;
};
const Modal: FC<Props> = ({
  isOpen,
  ...unhandled
}) =>
  isOpen ? (
    <Overlay {...unhandled} />
  ) : null;
```

<Wisdom>
Writing declarative interfaces takes careful intention
by the developer. Field names should represent clear descriptors of the data,
or signal clear behavioral intent. This makes it easy for other developers to
understand the purpose of each field and how it affects the component's behavior.

```tsx
// ‚ùå Bad example. Non-descriptive names and missing documentation lead to confusion.
const Widget = ({ a, b }: { a: string; b: string }) => (
  <div>
    <span>{a}</span>
    <span>{b}</span>
  </div>
);
```

It can be tempting to accept data in whatever shape you currently have it,
and design a component interface around that rather than design an interface
that is tailored to the component's intrinsics. Learn to identify these scenarios
and avoid hastily accepting data structures that do not align with the component's
purpose.
"Declarative interfaces" is analogous to data modeling, but with focus at the
component boundary.

```tsx
// ‚ùå Bad example. Using foreign data model, vs component local data model.
// Let's build a component that shows a product's prices, with a discount!
type DiscountPriceProps = {
  items: Item[]; // we accept all of the products,
  index: number; // and which product index it is
  // ü§î. Does a price viewer need knowledge of all of the items? Does it need
  // to know about the index? Certainly not!
};
const DiscountPrice: FC<
  DiscountPriceProps
> = ({
  items,
  index,
  className,
  ...unhandled
}) => {
  // The below logic handles cases that are not pertinent to drawing discounted
  // prices--it is only relevant to handling one callsite's obscure data model.
  // Data transformations should almost always be handled earlier in the call stack.
  if (
    !items ||
    index < 0 ||
    index >= items.length
  )
    return null;
  const item = items[index];
  return (
    <div
      className={clsx(
        "price",
        className,
      )}
      {...unhandled}
    >
      {item.discountedPrice
        ? item.discountedPrice
        : item.price}
    </div>
  );
};
```

</Wisdom>

<hr />

## 2. Thou shalt compose with anatomical components

**Principle**: Composable design

```tsx
const Card: FC<Props> = ({
  content,
  title,
  ...unhandled
}) => (
  <div {...unhandled}>
    <Heading>{title}</Heading>
    {content}
    <Footer />
  </div>
);
```

<Wisdom>
Assembling smaller components into larger components is a well
established strategy to build robust and malleable components. The above example
demonstrates the principle by isolating `Heading` and `Footer` from
`Card` component. Building small components supports...

1. reusability (`Heading` can be freely used elsewhere),
2. maintainability (`Heading` & `Footer` can be developed in isolation),
3. comprehension (`Heading` & `Footer` can be studied in isolation),
4. testability (`Heading` & `Footer` can be tested in isolation, or swapped in `Card` during test if needed),
5. and separation of concerns.

</Wisdom>

<hr />

## 3. Thou shalt forward unhandled input

**Principle**: Extensibility by default

```tsx
type Props = {
  foo: string;
} & HTMLAttributes<HTMLDivElement>;

const Widget: FC<Props> = ({
  foo,
  ...unhandled
}) => <div {...unhandled}>{foo}</div>;
```

<Wisdom>
Components shall by default extend their root child component. Any
unhandled input (props, attributes, etc.) should be passed down to the
underlying component or DOM element. This permits great extensibility and
ensures that the component can be extended by the consumer
without needing to modify the component itself.

Does the caller need to pass an `id`? How about a click handler?
Following this commandment, your component already supports your
caller's needs.

</Wisdom>

<hr />

## 4. Thou shalt separate presentation from logic

**Principle**: Separation of concerns

```tsx
// Presentational concerns
const UserCard = ({ name, bio, ...rest }: User & DivAttrs) => (
  <div {...rest}>
    <h1>{name}</h1>
    <p>{bio}</p>
  </div>
);

// Logic concerns
const UserCardContainer = ({userId, ...rest}) => {
  const [userData, setUserData] = React.useState<User | null>(null);
  const { data, loading, error } = useQuery(getUser);
  if (loading) return <div {...rest}>Loading...</div>;
  if (error) return <ErrorCard {...rest} error={error} />
  return <UserCard {...data} {...rest} />;
};
```

<Wisdom>
In our UserCardContainer, the bulk of the code is focused on
getting data and handling interstitial states. Once a state is
known, we pass the state into a presentational layer to take over
the rest.

The benefits of this are numerous:
1. **Maintainability**: Logic and presentation can be maintained separately. If you need to change the logic for fetching user data, you can do so without affecting the presentation layer.
2. **Reusability**: The presentational component can be reused in other parts of the application without the logic layer, allowing for greater flexibility in how the component is used.
3. **Testability**: By separating concerns, you can write unit tests for both the logic and presentation layers independently. This makes it easier to ensure that each part of the component is working correctly.
4. **Comprehension**: Separating concerns makes it easier for developers to understand the purpose of each part of the component. The logic layer handles data fetching and state management, while the presentation layer focuses on rendering the UI.
5. **Collaboration**: In a team environment, different developers can work on the logic and presentation layers simultaneously without stepping on each other's toes. This can lead to faster development cycles and more efficient teamwork.


```tsx
// ‚ùå Avoid: A monolithic component handling both fetching and rendering.
const UserDashboard = () => {
  const [userData, setUserData] = React.useState(null);
  React.useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => setUserData(data));
  }, []);
  if (!userData) return <div>Loading...</div>;
  return (
    <div>
      <h1>{userData.name}</h1>
      <p>{userData.bio}</p>
    </div>
  );
};
```
</Wisdom>

<hr/>

## 5. Thou shalt minimize state

## 10. Thou shalt invert control for high extensibility cases

**Principle**: Portability

```tsx
/// Setup - Consider component `Bar` which renders a `Foo`. The user may want
// to modify or change how `Foo` is rendered, including updating or overriding
// default props.

// foo.tsx
export const Foo = ({ foo, ...rest }) => (
  <div {...rest}>{foo}</div>
);

// bar.tsx
type Props = {
  /**
   * Inversion of Control (IoC) utilizes callbacks to render the
   * Foo component. This is known as the render-props pattern in React.
   */
  foo?: ({
    Component: Foo,
    props: FooProps,
  }) => JSX.Element;
};
const Bar: FC<Props> = ({
  foo,
  ...unhandled
}) => {
  const fooProps: FooProps = {
    className: "bg-blue flex",
    foo,
  };
  return (
    <div {...unhandled}>
      {foo({
        Component: Foo,
        props: fooProps,
      }) ?? <Foo {...fooProps} />}
    </div>
  );
};

// Usage. Observe using
// your-app.tsx
<Bar
  foo={({
    Component,
    props: { className, ...unhandled },
  }) => (
    <Component
      id="my-foo"
      className={`${className} my-classname`}
      {...unhandled}
      foo="Squashed foo!"
    />
  )}
/>;
```

<Wisdom>

Inversion of control (IoC), as administered via render props, is a powerful technique that allows a
component to delegate the responsibility of rendering a part of its
interface to its caller. This is particularly useful when you want to
provide a high degree of flexibility and extensibility in your
component's design. By allowing the caller to specify how a part of
the component should be rendered, you enable them to customize the
component's behavior and appearance without needing to modify the
component itself.

</Wisdom>

<hr />

